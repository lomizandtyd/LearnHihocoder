# KMP字符串搜索算法解题总结


## 核心要点
1. 核心思想
2. 求解next数组
3. 应用next数组搜索字符串


## 核心思想

KMP算法显然是对穷举法的一种剪枝优化。
在字符串搜索的过程中，有两种情况：
    1. 第一字符不匹配；
    2. 模式串的部分前缀匹配，接着出现了不匹配；
以上两种情况都非常常见，KMP算法主要针对第二点进行优化。
在穷举法中，第二种情况出现后，原串对齐点向右移一位，模式串指针归0重新匹配。
有很多文章描述了，当前缀匹配的情况下，模式串指针可以不用归0，而是从某一处直接开始，相应的对齐点移动位置也不再是1。

比如原始串为ABABCABABD，与ABABD做匹配时，[ABAB]C与[ABAB]D匹配，但C和D不匹配。
如果是穷举法，接下来原串A[B]ABCA，对齐点为B，模式串从[A]BABD 开始匹配。
但实际际可以跳转到， AB[AB]C 与[AB]ABD 开始匹配。

为了实现这种自动跳转，需要计算跳转数组，并根据跳转数组实现字符串搜索。


## 求解Next数组

求解Next数组，比较有意思的一点是：共同前缀由模式串本身就可以得到。

假设在模式串p的j位置处，出现了不匹配；
而我们将模式串移动了一定位置，使模式串前k个字符与[j-k, j-1]的字符相同。
那么我们下次在原串中搜索出现这一模式的时候，就应该直接跳转到模式串的k位置继续进行搜索。

在这种情况下，我们推导j+1处的发展：
如果j处与模式串的k+1字符匹配，而在j+1处出现不匹配，那j+1就应该跳转到k+1，原因同上；
如果j处与模式串的k+1字符不匹配，那么k就应该跳转到next[j]；

那不知道next[j]咋办？从上面的递推关系式中，可以看到next[j] 是在j-1时就应该获得了。
写成代码也就是：
```C++
if (p[j] == p[k]) {
    j++; k++;
    next[j] = k;
}
else {
    k = next[j]; // 这里写k或j是一样的，因为都描述了对齐点到不对齐位置的距离
}
```

递推关系还有一个问题是，起始位置怎么办。
假设第一个字符就不匹配，我们应当将原始串指针向右移一位，并重新开始比对模式串的第1个字符；
考虑到写代码时，如果i表示原串与模式串对齐点的位置，k表示模式串比对位置；
并且是从0开始计数的，因此i=0；
那么下一个状态i=1的跳转 k(@i=1)==0; 且k(@i=1) = k(@i=0) + 1 -> k==-1, i==0。

因此，可以写出next数组的计算代码：
```
int* next = new int[pat_size + 10];
next[0] = -1;

int j=0, k=-1;
while (j<pat_size) {
    if (p[j] == p[k]) {
        j++; k++;
        next[j] = k;
    }
    else {
        k = next[j]; // 这里写k或j是一样的，因为都描述了对齐点到不对齐位置的距离
    }
}

// do free
// delete next;
```

## 使用next数组

实际已经在上节中描述了如何使用next数组。

即
```
假设在模式串p的j位置处，出现了不匹配；
而我们将模式串移动了一定位置，使模式串前k个字符与[j-k, j-1]的字符相同。
那么我们下次在原串中搜索出现这一模式的时候，就应该直接跳转到模式串的k位置继续进行搜索。
```

与next代码相似的过程，代码如下：
```C++

int i=0, k=0; //因为要从模式串第一个字符开始匹配

while (i < src_size) {
    if (k == -1 || pat[k] == src[i]) {
        k++; i++;
    }
    else {
        k = next[k]; // 此时仅有k描述了对齐点到不匹配位置的长度
    }
}
```

## 更简短的kmp代码

显然next的计算过程和应用过程是一致的，
完全可以在搜索过程中再计算next数组。
因此根据这一原理，可以简化kmp代码，但是可能会增加重复计算量。
