# 最长回文字符串解题总结


## 核心要点
1. 奇偶同形处理
2. Manacher解法


## 奇偶同形处理

回文字符串，存在奇数串和偶数串两种形式，两种风格类似，但可实际边界情况略有区别。
在每个中心位置处判断时，都需要分别判断奇串和偶串。
可以通过间隔插入符号的方式，使偶串变成奇串。

应该先插入符号还是先放置字符呢？
我们期望外扩半径与回文字符串相等，也就是每判断一个真实字符，就会有一个相同的符号相外扩展。
如果是奇数串的情况，比如`aba`，有两种插入方法，`$#a#b#a#\0`，或者`$a#b#a\0`。
只有第一种情况，可以在满足终止条件停止时，半径等于回文串长。

因此插入部分的代码为
```C++
char str[1000002 * 2];
char buff[1000002];

int main() {
    int n;
    str[0] = '$';

    scanf("%d", &n);
    while (n--) {
        scanf("%s", buff);
        int i=0;
        for (i=0; buff[i]; ++i) {
            str[2 * i + 1] = '#';
            str[2 * i + 2] = buff[i];
        }
        str[2*i+1] = '#';
        str[2*i+2] = '\0';
        printf("%d\n", maximum_size_of_symmetry(str));
    }
    return 0;
}
```


## Manacher 算法

穷举的方式解决回文子串的问题：
```
对于字符串中的每一个字符
    1. 将其作为对称中心
    2. 由对称中心向两侧展开，搜索最长回文子曲
```

Manacher算法，更改了穷举法中间第2条的条件，即`由对称中心向两侧展开`处，大大降低了搜索空间。

假设当前对称中心存在于某个回文子串的右臂中；
那么当前对称中心的最小回文串长度和对称位置的回文串长度一致，
但因所存在的回文子串没有覆盖全部的字符，超过左臂左边界的字符不一定和右臂右边界的字符一致，
只能保证满足是对称位置的回文串长度和当前位置到右臂右边界的两者之中的最小值。

```
对于字符串中的每一个字符
    1. 将其作为对称中心
    2. 如果对称中心存在于某一已知的回文子串内
    3. 将以该回文子串对称位置的最大回文串长度和当前对称中心到该回文子串右臂边界的最小值作为搜索起始位置
    4. 向两侧展开搜索，得到最大回文子串长度，并记录这一长度
```

核心问题是如何得到对称中心存在于已知的回文子串？
一个对称中心可能同时存在于多个回文子串中；
由于我们搜索时向右探索，因此可以记录右边界最远的回文子串，来尽量覆盖最多的对称中心；
相当于在上面增加第5点。
```
    5. 如果当前最大回文子串右臂边界大于已知最右回文子串的右臂边界，用当前最大回文子串更新已知最右回文子串的右边界。
```
